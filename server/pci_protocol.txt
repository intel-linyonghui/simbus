
PCI bus simulations have these signals:


              Name       host     device
              ----       ----     ------
Misc.
              PCI_CLK     I         I
              RESET#      O         I
	      IDSEL       I         I    (See "IDSEL mapping")
	      INTA#       I*        O    (See "INTx# mapping")
	      INTB#       I*        O    (        "          )
	      INTC#       I*        O    (        "          )
	      INTD#       I*        O    (        "          )
Arbitration
              REQ#        O         O
	      GNT#        I         I
Control
	      FRAME#      B	    B
	      REQ64#      B	    B
	      IRDY#	  B	    B
	      TRDY#	  B	    B
	      STOP#	  B	    B
	      DEVSEL#	  B	    B
	      ACK64#	  B	    B
Address/Data
	      AD	  B         B
	      C/BE#	  B	    B
	      PAR	  B	    B
	      PAR64	  B	    B

* The PCI Clock

This is entirely under the control of the server. The server generates
the clock and 4 phase points where the bus device can receive/report
signals. The server uses "UNTIL" messages to advance through the
phases of the PCI clock. The "UNTIL" message starts the phase and
includes the signal values that the client should use within that
phase. Clients should assume that those signal values were valid at
least dT before the phase starts. This is most pertinent for phase-A,
clock posedge. This sketch shows the phases:

                   C        D A B        C
                   |        | | |        |
                   V        V V V        V
        +----------+          +----------+
        |          |          |          |
        |          |          |          |
   -----+          +----------+          +----------

  A  - The posedge of the clock. At this point, since the bus is
       synchronous, all the signals should be stable and can be
       tested. The values that the client receives from the server to
       start this phase were reported at the beginning of phase-D, or
       earlier. This phase is 2ns wide.

  B  - Signal hold. This is a chance for clients to change signals in
       response to the posedge of the clock. This phase is 14.5ns.

  C  - The negedge of the clock. Another chance to change
       signals. This phase is 14.5ns.

  D  - Signal Setup. This is the last chance for clients to change
       signal values for the upcoming posedge. Signal values in the
       "READY" message will arrive at other clients with the start of
       phase-A. This phase is 2ns.


* IDSEL mapping

On a PCI bus, the device number is used to select the IDSEL signal
that is routed to it. The bus supports 16 directly-connected devices
(including hosts) and the device number may be a value from 0-15
inclusive. The IDSEL signal is generated from the AD bus, with IDSEL
for device-0 connected to AD[16], IDSEL for device-1 to AD[17], and so
on up to device-15 to AD[31]. Hosts and devices are treated equally by
the server. The IDSEL mapping is done by the server, so any bus master
(device or host) can generate configuration cycles with the desired
IDSEL bits set.

* INTx# mapping

Devices (not hosts) have 4 interrupt outputs, INTA#, INTB#, INTC# and
INTD#. These are used as expected.

Hosts, on the other hand, only have interrupt *inputs*. The host sees
the signals INTA#, INTB#, INTC# and INTD# for as 16bit vectors, with
each bit position of the vector representing the interrupt for the
corresponding device. Thus the host sees and can differentiate all the
interrupts from all the devices. If the host simulation wants to
simulate shared interrupts, it does so internally.

The INTx# interrupts for a device are allocated to a bit in the INTx#
vector by the device number. For example, device 0 drives INTA#[0],
device 1 drives INTA#[1], and so forth.

* Arbitration

The server contains the arbitor, so the host is treated like any other
device with its own REQ# and GNT# signals.

* Address/Data

The PCI protocol supports 64bit busses. The AD vector is 64bits and
the C/BE# vector is 8 bits always.  If a device is only being a 32bit
device, then it will send Z bits in the high 32 of the AD vector and
the high 4 bits of C/BE#. This keeps the protocol handling uniform.
